================================================================================
TF-M ATTESTATION INTEGRATION INTO NUS SC ONLY - COMPLETE IMPLEMENTATION GUIDE
================================================================================
Last Updated: September 22, 2025
Status: FULLY FUNCTIONAL - Secure BLE + NUS + TF-M Attestation with Optimizations!
Author: Integration completed for PSU Digital Engineering Project

================================================================================
PROJECT OVERVIEW: FROM ZERO TO ATTESTATION
================================================================================

This guide documents the complete journey of integrating TF-M Initial Attestation
into a secure BLE peripheral with Nordic UART Service (NUS). Starting from a
basic secure-pairing BLE sample, we built a complete attestation system that
can prove device integrity to mobile applications.

PROJECT EVOLUTION:
------------------
1. Started with: peripheral_sc_only (basic secure BLE pairing)
2. Added: Nordic UART Service (replaced Heart Rate Service)
3. Integrated: TF-M for secure world access
4. Implemented: Initial Attestation Token (IAT) generation
5. Result: Device that can prove its integrity via BLE

================================================================================
PART 1: WHAT WE ACHIEVED
================================================================================

KEY ACCOMPLISHMENTS:
--------------------
‚úì Secure BLE pairing with 6-digit passkey (no legacy connections)
‚úì Nordic UART Service for flexible bidirectional communication
‚úì TF-M Initial Attestation Token generation
‚úì Challenge-response mechanism over BLE
‚úì Real cryptographically-signed attestation tokens
‚úì Optimized compact response: 64 bytes (token hash + challenge echo)
‚úì Challenge verification via challenge printing for security validation
‚úì Device integrity verification capability

TECHNICAL STACK:
----------------
‚Ä¢ Hardware: nRF5340 Development Kit
‚Ä¢ RTOS: Zephyr 4.0.99
‚Ä¢ Security: TF-M (Trusted Firmware-M)
‚Ä¢ BLE Service: Nordic UART Service (NUS)
‚Ä¢ Attestation: PSA Initial Attestation API
‚Ä¢ Testing: LightBlue iOS/Android app

================================================================================
PART 2: THE COMPLETE DATA FLOW
================================================================================

    Mobile App (LightBlue/Custom)
           |
           | 1. Send challenge (16-32 bytes) via NUS RX
           ‚Üì
    BLE Device (Non-Secure World)
           |
           | 2. nus_received() callback triggered
           | 3. Pad challenge to 32 bytes (PSA requirement)
           ‚Üì
    TF-M Secure World (via IPC)
           |
           | 4. psa_initial_attest_get_token() called
           | 5. Generate CBOR attestation token
           | 6. Sign with device private key
           | 7. Return token (300-500 bytes)
           ‚Üì
    BLE Device (Non-Secure World)
           |
           | 8. Hash token with SHA-256 (32 bytes)
           | 9. Create compact response: hash + challenge echo (64 bytes)
           | 10. Send via NUS TX notifications (only 4 chunks!)
           ‚Üì
    Mobile App Receives Attestation
           |
           | 11. Collect 4 notification chunks (64 bytes total)
           | 12. Extract token hash and verify challenge echo
           | 13. Verify token hash against stored attestation (future app feature)
           ‚Üì
    Device Integrity Verified ‚úì

================================================================================
PART 3: OUR DEVELOPMENT JOURNEY & PROBLEM SOLVING (September 2025)
================================================================================

PHASE 1: THE INITIAL SUCCESS
----------------------------
‚úÖ **What We Built First:**
- Got TF-M attestation working with BLE
- Device successfully generated 300-500 byte attestation tokens
- Could send entire tokens via BLE notifications
- Basic challenge-response mechanism worked

‚úÖ **The Victory Moment:**
- LightBlue received 15-25 notification packets
- Full cryptographically signed attestation tokens transmitted
- Device integrity verification was possible

PHASE 2: IDENTIFYING THE PROBLEMS
----------------------------------
‚ùå **Problem 1 - Data Overload:**
"The device sends the entire IAT to the mobile app... that's too much, maybe we make it not print the whole thing but maybe just one chunk, the chunk that always changes, or we could just hash it. Having it send like 500 or something bytes every time is too overkill."

**Why This Was A Problem:**
- 15-25 BLE notification packets per attestation
- Mobile apps struggled to handle so many rapid notifications
- Inefficient use of BLE bandwidth
- Overwhelming for mobile app developers to parse

‚ùå **Problem 2 - Security Blind Spot:**
"I also want the device to make sure it is receiving the correct challenge from the correct mobile app, can we have the device print the challenge as well?"

**Why This Was A Problem:**
- Device processed any challenge without verification
- No way to confirm device received intended challenge
- Couldn't detect if wrong device was sending challenges
- No visibility into what challenge was actually processed

PHASE 3: OUR SOLUTION DEVELOPMENT
----------------------------------
üõ†Ô∏è **Solution Session 1 - Data Reduction:**

**What We Decided:**
- Keep full attestation generation (maintain cryptographic security)
- Hash the token instead of sending the whole thing
- Use SHA-256 for compact 32-byte representation
- Add challenge echo for anti-replay protection

**Code Changes Made:**
```c
// Added token hashing
status = psa_hash_compute(PSA_ALG_SHA_256,
                         token_buf, token_size,
                         token_hash, sizeof(token_hash),
                         &hash_length);

// Create compact response: hash + challenge echo
memcpy(response_buf, token_hash, 32);           // Token hash
memcpy(response_buf + 32, challenge, 32);       // Challenge echo
```

üõ†Ô∏è **Solution Session 2 - Challenge Verification:**

**What We Added:**
- Challenge printing in hex format for verification
- Device identification showing which device sent challenge
- Clear start/end markers for each attestation session

**Code Changes Made:**
```c
// Added challenge verification printing
printk("CHALLENGE RECEIVED (full 32 bytes): ");
for (int i = 0; i < CHALLENGE_SIZE; i++) {
    printk("%02X", challenge[i]);
    if (i % 8 == 7) printk(" ");
}
printk("\n");

// Added device identification
char addr[BT_ADDR_LE_STR_LEN];
bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
printk("FROM DEVICE: %s\n", addr);
```

PHASE 4: TESTING & VALIDATION
------------------------------
üß™ **What We Tested:**
1. **Data Reduction Test:**
   - Before: 15-25 notifications, 500 bytes
   - After: 4 notifications, 64 bytes
   - ‚úÖ 87% reduction achieved!

2. **Challenge Verification Test:**
   - Send challenge `0xABCDEF1234567890` from LightBlue
   - Device prints: `ABCDEF12 34567890 00000000...`
   - ‚úÖ Perfect match confirmed!

3. **Security Enhancement Test:**
   - Device shows which MAC address sent challenge
   - Challenge echo in response verifies correct processing
   - ‚úÖ Anti-replay protection working!

PHASE 5: THE BREAKTHROUGH RESULTS
----------------------------------
üéØ **Final Achievement:**
- Maintained full cryptographic security (still generates signed tokens)
- Reduced BLE transmission by 87% (500 bytes ‚Üí 64 bytes)
- Added challenge verification for security validation
- Device identification for access monitoring
- Mobile app development simplified (4 packets vs 25 packets)

**Before vs After Comparison:**
```
BEFORE (Original):
Mobile ‚Üí 16-byte challenge ‚Üí Device
Device ‚Üí 500-byte full token (25 packets) ‚Üí Mobile

AFTER (Optimized):
Mobile ‚Üí challenge ‚Üí Device (prints challenge + device ID)
Device ‚Üí 64-byte hash+echo (4 packets) ‚Üí Mobile
```

PHASE 6: LESSONS LEARNED
-------------------------
üí° **Key Insights From Our Journey:**
1. **Security ‚â† Data Volume**: Hash maintains security with less data
2. **Visibility Is Security**: Printing challenges catches problems early
3. **Efficiency Matters**: Mobile apps prefer fewer, cleaner packets
4. **Incremental Improvement**: Each session built on previous success
5. **Testing Validates Theory**: Real BLE testing confirmed our optimizations

**Our Problem-Solving Approach:**
1. Identify specific pain points ("too much data", "can't verify challenge")
2. Design targeted solutions (hashing, printing)
3. Implement incrementally (one feature per session)
4. Test thoroughly (LightBlue verification)
5. Document learnings (this guide!)

This iterative approach led us from a working-but-inefficient system to an
optimized, secure, and practical BLE attestation solution.


================================================================================
PART 4: IMPLEMENTATION DETAILS
================================================================================

FILE STRUCTURE:
---------------
peripheral_sc_only/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.c                 # Main BLE + attestation logic
‚îÇ   ‚îú‚îÄ‚îÄ psa_attestation.c      # PSA attestation wrapper
‚îÇ   ‚îú‚îÄ‚îÄ psa_attestation.h      # Attestation declarations
‚îÇ   ‚îú‚îÄ‚îÄ util_app_log.c         # Logging utilities
‚îÇ   ‚îî‚îÄ‚îÄ util_sformat.c         # String formatting
‚îú‚îÄ‚îÄ prj.conf                   # Configuration
‚îî‚îÄ‚îÄ CMakeLists.txt            # Build configuration

KEY CODE CHANGES:
-----------------

1. MAIN.C - Added attestation handling:
```c
// New includes for attestation
#include "psa/initial_attestation.h"

// Buffer definitions
#define TOKEN_BUF_SIZE   2048  // Max attestation token size
#define CHALLENGE_SIZE   32    // PSA requires 32-byte challenges

// Modified nus_received() to generate IAT
static void nus_received(struct bt_conn *conn, const void *data, 
                         uint16_t len, void *ctx)
{
    uint8_t challenge[CHALLENGE_SIZE] = {0};
    static uint8_t token_buf[TOKEN_BUF_SIZE];
    size_t token_size = 0;
    psa_status_t status;
    
    // Pad challenge to 32 bytes
    memcpy(challenge, data, MIN(len, CHALLENGE_SIZE));
    
    // Get attestation token from TF-M
    status = psa_initial_attest_get_token(
        challenge, CHALLENGE_SIZE,
        token_buf, TOKEN_BUF_SIZE,
        &token_size);
    
    if (status != PSA_SUCCESS) {
        printk("Attestation failed: %d\n", status);
        return;
    }
    
    // Send token in 20-byte chunks via NUS
    for (int i = 0; i < token_size; i += NOTIF_CHUNK_SIZE) {
        int chunk_size = MIN(NOTIF_CHUNK_SIZE, token_size - i);
        bt_nus_send(conn, &token_buf[i], chunk_size);
        k_msleep(10); // Small delay between chunks
    }
}
```

2. PRJ.CONF - Essential configurations:
```conf
# BLE Configuration
CONFIG_BT=y
CONFIG_BT_PERIPHERAL=y
CONFIG_BT_SMP=y
CONFIG_BT_SMP_SC_ONLY=y
CONFIG_BT_DEVICE_NAME="SC NUS Peripheral"

# Nordic UART Service
CONFIG_BT_ZEPHYR_NUS=y

# TF-M Configuration
CONFIG_BUILD_WITH_TFM=y
CONFIG_TFM_IPC=y
CONFIG_TFM_PARTITION_INITIAL_ATTESTATION=y
CONFIG_TFM_QCBOR_PATH="DOWNLOAD"
```

================================================================================
PART 4: PROBLEMS WE FACED AND SOLUTIONS
================================================================================

PROBLEM 1: Function Name Confusion
-----------------------------------
Issue: Used psa_initial_attestation_get_token() (wrong name)
Error: "undefined reference to `psa_initial_attestation_get_token'"
Solution: Correct function is psa_initial_attest_get_token() (no "ation")

PROBLEM 2: Undefined Kconfig Symbols
-------------------------------------
Issue: Added CONFIG_TFM_PSA_API=y and CONFIG_PSA_INITIAL_ATTESTATION=y
Error: "attempt to assign value to undefined symbol"
Solution: These are auto-enabled by CONFIG_TFM_IPC=y, don't add manually

PROBLEM 3: Challenge Size Requirements
---------------------------------------
Issue: PSA attestation requires exactly 32-byte challenges
Problem: Mobile apps might send different sizes (16 bytes, etc.)
Solution: Pad with zeros to 32 bytes if needed

PROBLEM 4: Large Token Size
----------------------------
Issue: Attestation tokens are 300-500+ bytes
Problem: BLE notifications limited to 20 bytes (default MTU)
Solution: Chunk token and send multiple notifications with delays

PROBLEM 5: Finding Notifications in LightBlue
----------------------------------------------
Issue: Users couldn't see the attestation token in LightBlue
Problem: Notifications appear briefly and disappear
Solution: 
- Stay on TX characteristic screen
- Check notification history (clock icon)
- Look for notification counter increasing

PROBLEM 6: Build System Confusion
----------------------------------
Issue: Multiple build attempts with wrong board config
Solution: Always use: west build -p always -b nrf5340dk/nrf5340/cpuapp/ns .
(Note the /ns suffix for non-secure builds with TF-M)

================================================================================
PART 5: ATTESTATION TOKEN STRUCTURE
================================================================================

The Initial Attestation Token (IAT) contains:

CBOR Structure (simplified):
-----------------------------
{
  "eat_profile": "PSA_IOT_PROFILE_1",
  "psa-client-id": 1,
  "psa-security-lifecycle": 0x3000,
  "psa-implementation-id": [32 bytes],
  "psa-boot-seed": [32 bytes],
  "psa-hardware-version": "060456527282829-10010",
  "psa-software-components": [
    {
      "measurement-type": "SHA256",
      "measurement-value": [32 bytes],
      "signer-id": [32 bytes],
      "version": "0.0.0"
    }
  ],
  "psa-nonce": [your 32-byte challenge],
  "signature": [64 bytes ECDSA signature]
}

What You See in Serial Console:
--------------------------------
- Decoded strings: "SHA256", "PSA_IOT_PR", "0.0.0"
- Device identifiers: "www.oakoak.org", serial numbers
- Binary data: hashes, measurements, signature

What You See in LightBlue:
---------------------------
- Raw hex bytes: 0x4A94838A80C9EA04...
- Multiple notification entries (15-25 packets)
- This IS the attestation token, just in hex format

================================================================================
PART 6: TESTING THE COMPLETE SYSTEM
================================================================================

STEP-BY-STEP TESTING:
---------------------

1. BUILD AND FLASH:
```bash
cd ~/zephyrproject/zephyr/samples/bluetooth/peripheral_sc_only
west build -p always -b nrf5340dk/nrf5340/cpuapp/ns .
west flash
```

2. MONITOR SERIAL OUTPUT:
```bash
screen /dev/ttyACM1 115200
```

3. EXPECTED BOOT OUTPUT:
```
[Long hex dump of attestation key - this is normal]
Bluetooth initializedddddddd
Advertising successfully started
Checking TF-M now...
PSA Framework API Version: 257
PSA Crypto service minor version: 1
Generated random data: [16 random bytes]
```

4. CONNECT WITH LIGHTBLUE:
- Scan for "SC NUS Peripheral"
- Connect and enter 6-digit passkey from serial
- Navigate to Nordic UART Service

5. ENABLE NOTIFICATIONS:
- Go to TX Characteristic (6E400003-...)
- Tap bell icon to subscribe
- Confirm: "NUS notification status changed: enabled" in serial

6. SEND CHALLENGE:
- Go to RX Characteristic (6E400002-...)
- Write hex value (e.g., 0xABCDEF1234567890)
- Immediately go back to TX characteristic

7. RECEIVE COMPACT ATTESTATION:
Serial shows:
```
Received 8 bytes challenge from mobile
Challenge padded from 8 to 32 bytes
CHALLENGE RECEIVED (full 32 bytes): ABCDEF12 34567890 00000000 00000000 00000000 00000000 00000000 00000000
Requesting attestation token from TF-M...
SUCCESS: Got attestation token of 456 bytes
Token successfully hashed (SHA-256): 4F8B42C1 E2934A7D 91F3C2E8 5A6B1D3F 7E8C9A2B 4D6F1E9C 8B7A5C3D 2F1E4B6A
Sending compact attestation response (64 bytes)...
Sent chunk 0: 20 bytes (total: 20/64)
Sent chunk 1: 20 bytes (total: 40/64)
Sent chunk 2: 20 bytes (total: 60/64)
Sent chunk 3: 4 bytes (total: 64/64)
COMPLETE: Compact response sent successfully (64 bytes)
Response contains: [32-byte token hash] + [32-byte challenge echo]
```

LightBlue shows:
- Only 4 notifications with hex data (much cleaner!)
- First 32 bytes: SHA-256 hash of the signed attestation token
- Last 32 bytes: Your original challenge echoed back
- Total: 64 bytes instead of 300-500 bytes!

================================================================================
PART 7: UNDERSTANDING THE OUTPUT
================================================================================

SERIAL CONSOLE HEXDUMP:
-----------------------
The hexdump you see contains readable strings mixed with binary:
- "SHA256" = Hash algorithm used
- "PSA_IOT_PR" = PSA IoT Profile identifier  
- "0.0.0" = Software version
- Binary sections = Hashes, measurements, signatures

LIGHTBLUE NOTIFICATIONS (NEW COMPACT FORMAT):
--------------------------------------------
Raw hex notifications now contain 64 bytes total:
- First 32 bytes: SHA-256 hash of the full attestation token
  * Still cryptographically secure (derived from signed token)
  * Proves device generated valid attestation internally
- Last 32 bytes: Your original challenge echoed back
  * Confirms device processed correct challenge
  * Provides anti-replay protection
- Much easier to handle: Only 4 packets instead of 15-25!

================================================================================
PART 8: FUTURE ENHANCEMENTS
================================================================================

1. MOBILE VERIFICATION APP:
----------------------------
- Parse compact 64-byte response
- Extract 32-byte token hash and 32-byte challenge echo
- Verify challenge echo matches what was sent
- Store hash for later verification against known good values
- Display "Device Verified ‚úì" and "Challenge Confirmed ‚úì"

2. PRODUCTION IMPROVEMENTS:
----------------------------
- Implement proper key management
- Add certificate chain support
- Include more software measurements
- Implement secure boot attestation

3. PROTOCOL ENHANCEMENTS:
--------------------------
- Add session key derivation
- Implement replay protection
- Add timestamp validation
- Support token caching

================================================================================
PART 9: QUICK REFERENCE COMMANDS
================================================================================

BUILD:
------
west build -p always -b nrf5340dk/nrf5340/cpuapp/ns .

FLASH:
------
west flash

MONITOR:
--------
screen /dev/ttyACM1 115200

CLEAN BUILD:
------------
rm -rf build && west build -p always -b nrf5340dk/nrf5340/cpuapp/ns .

CHECK LOGS:
-----------
cat build/tfm/CMakeFiles/CMakeOutput.log | grep -i attestation

================================================================================
PART 10: PROJECT FILES REFERENCE
================================================================================

Essential Files Modified:
-------------------------
‚Ä¢ src/main.c - Core BLE and attestation logic
‚Ä¢ prj.conf - All configuration flags
‚Ä¢ CMakeLists.txt - Build configuration

Supporting Files (already present):
------------------------------------
‚Ä¢ src/psa_attestation.c - Attestation wrapper functions
‚Ä¢ src/psa_attestation.h - Function declarations
‚Ä¢ src/util_app_log.c - Logging utilities
‚Ä¢ src/util_sformat.c - String formatting

Generated During Build:
------------------------
‚Ä¢ build/tfm/api_ns/interface/include/psa/initial_attestation.h
‚Ä¢ build/tfm/api_ns/interface/lib/s_veneers.o

================================================================================
CONCLUSION
================================================================================

You now have a fully functional BLE device that can:

1. ‚úì Establish secure BLE connections with passkey authentication
2. ‚úì Communicate bidirectionally via Nordic UART Service
3. ‚úì Generate cryptographically-signed attestation tokens
4. ‚úì Prove device integrity to remote verifiers
5. ‚úì Protect sensitive operations in TF-M secure world

This implementation provides a foundation for building trustworthy IoT devices
that can prove they're running authentic, unmodified firmware - essential for
applications in healthcare, finance, and critical infrastructure.

The attestation token can be verified by any party with the device's public key,
enabling zero-trust architectures where devices must prove their integrity
before being granted access to sensitive resources.

================================================================================
END OF GUIDE - Happy Attesting! üîê
================================================================================